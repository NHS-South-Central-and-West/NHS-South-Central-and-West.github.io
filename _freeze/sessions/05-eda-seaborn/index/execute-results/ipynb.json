{
  "hash": "a28511b75845d18f39d1fe151bd0315d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Visually Exploring Data Using Seaborn\"\nformat:\n  html: default\n  ipynb: default\n---\n\nWe are using Australian weather data, taken from Kaggle. To download the data, click <a href=\"data/weatherAUS.csv\" download>here</a>.\n\n::: {#setup .cell execution_count=1}\n``` {.python .cell-code}\n# import packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n# import the dataset\ndf = pd.read_csv('data/weatherAUS.csv')\n```\n:::\n\n\nObjectives:\n\n- Understand how to describe data quantitatively and when different methods are appropriate\n- Visualise data as a means of describing it\n- Show how to visualising data is a shortcut for describing central tendency, spread, uncertainty etc.\n- Introduce ideas around describing and visualising relationships between variables\n\n::: {#big-cities-subset .cell execution_count=2}\n``` {.python .cell-code}\n# subset of observations from five biggest cities\nbig_cities = (\n    df.loc[df['Location'].isin(['Adelaide', 'Brisbane', 'Melbourne', 'Perth', 'Sydney'])]\n    .copy()\n)\n```\n:::\n\n\n## Visualising a Single Variable\n\n- What do we want to know when we are visualising a sample taken from a single variable?\n- We want to understand the value that the value tends to take, and how much it tends to deviate from its typical value.\n    - The central tendency and deviation are ways to describe a sample.\n    - Visualising the distribution of a variable can tell us these things (approximately), and can tell us about the shape of the data too.\n\n### Describing a Sample\n\n- What is the best way to describe a variable?\n    - What is the average value? Or the value it is most likely to take? What is the best value to describe it in one go?\n- The \"central tendency\" is the average or most common value that a variable takes. Mean, median, and mode are all descriptions of the central tendency.\n    - Mean - Sum of values in a sample divided by the total number of observations\n    - Median - The midpoint value if the sample is ordered from highest to lowest\n    - Mode - The most common value in the sample\n- The mean is the most common approach, but the mean, median, and mode choice are context-dependent. Other approaches exist, too, such as the geometric mean.\n    - The geometric mean multiplies all values in the sample and takes the $n$th root of that multiplied value.\n    - It can be useful when dealing with skewed data or data with very large ranges, and when dealing with rates, proportions etc. However it can't handle zeros or negative values.\n- The mode value is generally most useful when dealing with categorical variables.\n\n::: {#cell-mode-rainfall .cell execution_count=3}\n``` {.python .cell-code}\n# mode rainfall by location\nbig_cities.groupby('Location')['Rainfall'].agg(pd.Series.mode)\n```\n\n::: {#mode-rainfall .cell-output .cell-output-display execution_count=3}\n```\nLocation\nAdelaide     0.0\nBrisbane     0.0\nMelbourne    0.0\nPerth        0.0\nSydney       0.0\nName: Rainfall, dtype: float64\n```\n:::\n:::\n\n\n::: {#cell-mode-location .cell execution_count=4}\n``` {.python .cell-code}\n# mode location\nbig_cities['Location'].agg(pd.Series.mode)\n```\n\n::: {#mode-location .cell-output .cell-output-display execution_count=4}\n```\n0    Sydney\nName: Location, dtype: object\n```\n:::\n:::\n\n\n::: {#cell-location-value-counts .cell execution_count=5}\n``` {.python .cell-code}\n# mode location using value counts\nbig_cities['Location'].value_counts().iloc[0:1]\n```\n\n::: {#location-value-counts .cell-output .cell-output-display execution_count=5}\n```\nLocation\nSydney    3344\nName: count, dtype: int64\n```\n:::\n:::\n\n\n::: {#cell-mean-rainfall-location .cell execution_count=6}\n``` {.python .cell-code}\n# mean rainfall by location\nnp.round(big_cities.groupby('Location')['Rainfall'].mean(), decimals=2)\n```\n\n::: {#mean-rainfall-location .cell-output .cell-output-display execution_count=6}\n```\nLocation\nAdelaide     1.57\nBrisbane     3.14\nMelbourne    1.87\nPerth        1.91\nSydney       3.32\nName: Rainfall, dtype: float64\n```\n:::\n:::\n\n\n::: {#cell-median-rainfall-location .cell execution_count=7}\n``` {.python .cell-code}\n# median rainfall by location\nbig_cities.groupby('Location')['Rainfall'].median()\n```\n\n::: {#median-rainfall-location .cell-output .cell-output-display execution_count=7}\n```\nLocation\nAdelaide     0.0\nBrisbane     0.0\nMelbourne    0.0\nPerth        0.0\nSydney       0.0\nName: Rainfall, dtype: float64\n```\n:::\n:::\n\n\n::: {#cell-mean-max-temp-location .cell execution_count=8}\n``` {.python .cell-code}\n# geometric mean max temperature by location\nbig_cities.groupby('Location')['MaxTemp'].apply(lambda x: np.exp(np.log(x).mean()))\n```\n\n::: {#mean-max-temp-location .cell-output .cell-output-display execution_count=8}\n```\nLocation\nAdelaide     21.888697\nBrisbane     26.152034\nMelbourne    19.972352\nPerth        24.320203\nSydney       22.570993\nName: MaxTemp, dtype: float64\n```\n:::\n:::\n\n\n- Why do the mean and median differ so much? Why would the median rainfall be zero for all five cities?\n- Does this matter? How would it change our understanding of the rainfall variable?\n- Visualising the distribution can tell us more!\n\n### Comparing the Mean & Median\n\n- We have simulated three different distributions that have slightly different shapes. and see how their mean and median values differ.\n\n::: {#simulate-skewed-distributions .cell execution_count=9}\n``` {.python .cell-code}\n# generate distributions\nnp.random.seed(123)\nnormal_dist = np.random.normal(10, 1, 1000)\nright_skewed_dist = np.concatenate([np.random.normal(8, 2, 600), np.random.normal(14, 4, 400)])\nleft_skewed_dist = np.concatenate([np.random.normal(14, 2, 600), np.random.normal(8, 4, 400)])\n```\n:::\n\n\n::: {#avg-plot-function .cell execution_count=10}\n``` {.python .cell-code}\n# import packages\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# control some deprecation warnings in seaborn\nwarnings.filterwarnings(\n    \"ignore\",\n    category=FutureWarning,\n    module=\"seaborn\"\n)\n\n# set figure size\nplt.rcParams['figure.figsize'] = (12, 6)\n\n# function for calculating summary statistics and plotting distributions\ndef plot_averages(ax, data, title):\n    mean = np.mean(data)\n    median = np.median(data)\n    \n    sns.histplot(data, color=\"#d9dcd6\", bins=30, ax=ax)\n    ax.axvline(mean, color=\"#0081a7\", linewidth=3, linestyle=\"--\", label=f\"Mean: {mean:.2f}\")\n    ax.axvline(median, color=\"#ef233c\", linewidth=3, linestyle=\"--\", label=f\"Median: {median:.2f}\")\n    ax.set_title(title)\n    ax.set_ylabel('')\n    ax.legend()\n```\n:::\n\n\n::: {#cell-plot-skewed-distributions .cell execution_count=11}\n``` {.python .cell-code}\n# plot distributions\nfig, axes = plt.subplots(1, 3, sharey=True)\n\nplot_averages(axes[0], normal_dist, \"Normal Distribution\\n(Mean â‰ˆ Median)\")\nplot_averages(axes[1], right_skewed_dist, \"Right-Skewed Distribution\\n(Mean > Median)\")\nplot_averages(axes[2], left_skewed_dist, \"Left-Skewed Distribution\\n(Mean < Median)\")\n\nplt.suptitle(\"Comparison of Mean & Median Across Distributions\", fontsize=16)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/plot-skewed-distributions-output-1.png){#plot-skewed-distributions}\n:::\n:::\n\n\n- The mean and median of the normal distribution are identical, while the two skewed distributions have slightly different means and medians.\n    - The mean is larger than the media when the distribution is right-skewed, and the median is larger than the mean when it is left-skewed.\n    - When the distribution is skewed, the median value will be a better description of the central tendency, because the mean value is more sensitive to extreme values (and skewed distributions have longer tails of extreme values).\n- These differences point to another important factor to consider when summarising data - the spread or deviation of the sample.\n- How do we measure how a sample is spread around the central tendency?\n    - Standard deviation and variance quantify spread.\n    - Variance, the average squared difference between observations and the mean value, measures how spread out a sample is.\n    - Standard deviation is the square root of the variance. It's easier to interpret because it's in the same units as the sample.\n\n::: {#simulate-variance-distributions .cell execution_count=12}\n``` {.python .cell-code}\n# generate distributions\nnp.random.seed(123)\nmean = 10\nstd_devs = [1, 2, 3]\ndistributions = [np.random.normal(mean, std_dev, 1000) for std_dev in std_devs]\n```\n:::\n\n\n::: {#spread-plot-function .cell execution_count=13}\n``` {.python .cell-code}\n# function for calculating summary statistics and plotting distributions\ndef plot_spread(ax, data, std_dev, title):\n    mean = np.mean(data)\n    std_dev = np.std(data)\n\n    sns.histplot(data, color=\"#d9dcd6\", bins=30, ax=ax)\n    ax.axvline(mean, color=\"#0081a7\", linewidth=3, linestyle=\"--\", label=f\"Mean: {mean:.2f}\")\n    ax.axvline(mean + std_dev, color=\"#ee9b00\", linewidth=3, linestyle=\"--\", label=f\"Mean + 1 SD: {mean + std_dev:.2f}\")\n    ax.axvline(mean - std_dev, color=\"#ee9b00\", linewidth=3, linestyle=\"--\", label=f\"Mean - 1 SD: {mean - std_dev:.2f}\")\n    ax.set_title(f\"{title}\")\n    ax.legend()\n```\n:::\n\n\n::: {#cell-plot-variance-distributions .cell execution_count=14}\n``` {.python .cell-code}\n# plot distributions\nfig, axes = plt.subplots(1, 3, sharey=True, sharex=True)\n\nfor i, std_dev in enumerate(std_devs):\n    plot_spread(axes[i], distributions[i], std_dev, f\"Standard Deviation = {std_dev}\")\n\nplt.suptitle(\"Effect of Standard Deviation on Distribution Shape\", fontsize=16)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/plot-variance-distributions-output-1.png){#plot-variance-distributions}\n:::\n:::\n\n\n- As standard deviation increases, the spread of values around the mean increases.\n- We can compute various summary statistics that describe a sample (mean, median, standard deviation, kurtosis etc. etc.), or we can just visualise it!\n- Visualising distributions is a good starting point for understanding a sample. It can quickly and easily tell you a lot about the data.\n\n::: {#cell-rainfall-distribution .cell execution_count=15}\n``` {.python .cell-code}\n# plot distribution of rainfall\nrainfall_mean = np.mean(big_cities['Rainfall'])\nrainfall_median = np.median(big_cities['Rainfall'].dropna())\n\nsns.histplot(data=big_cities, x='Rainfall', binwidth=10, color=\"#d9dcd6\")\nplt.axvline(rainfall_mean, color=\"#0081a7\", linestyle=\"--\", linewidth=2, label=f\"Mean: {rainfall_mean:.2f}\")\nplt.axvline(rainfall_median, color=\"#ef233c\", linestyle=\"--\", linewidth=2, label=f\"Median: {rainfall_median:.2f}\")\n\nplt.title(\"Distribution of Rainfall in Australia's Big Cities\")\n\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/rainfall-distribution-output-1.png){#rainfall-distribution}\n:::\n:::\n\n\n::: {#cell-sunshine-distribution .cell execution_count=16}\n``` {.python .cell-code}\n# plot distribution of sunshine\nsunshine_mean = np.mean(big_cities['Sunshine'])\nsunshine_median = np.median(big_cities['Sunshine'].dropna())\n\nsns.histplot(data=big_cities, x='Sunshine', binwidth=1, color=\"#d9dcd6\")\nplt.axvline(sunshine_mean, color=\"#0081a7\", linestyle=\"--\", linewidth=2, label=f\"Mean: {sunshine_mean:.2f}\")\nplt.axvline(sunshine_median, color=\"#ef233c\", linestyle=\"--\", linewidth=2, label=f\"Median: {sunshine_median:.2f}\")\n\nplt.title(\"Distribution of Sunshine in Australia's Big Cities\")\n\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/sunshine-distribution-output-1.png){#sunshine-distribution}\n:::\n:::\n\n\n- These two plots require a little more code, but we can get most of what we want with a lot less.\n\n::: {#cell-max-temp-distribution .cell execution_count=17}\n``` {.python .cell-code}\nsns.histplot(data=big_cities, x='MaxTemp')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/max-temp-distribution-output-1.png){#max-temp-distribution}\n:::\n:::\n\n\n::: {#cell-location-distribution .cell execution_count=18}\n``` {.python .cell-code}\nsns.countplot(big_cities, x='Location', color=\"#d9dcd6\", edgecolor='black')\nplt.ylim(3000, 3500)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/location-distribution-output-1.png){#location-distribution}\n:::\n:::\n\n\n::: {#cell-rain-tomorrow-distribution .cell execution_count=19}\n``` {.python .cell-code}\nsns.countplot(big_cities, x='RainTomorrow', color=\"#d9dcd6\", edgecolor='black')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/rain-tomorrow-distribution-output-1.png){#rain-tomorrow-distribution}\n:::\n:::\n\n\n::: {#cell-count-rain-tomorrow .cell execution_count=20}\n``` {.python .cell-code}\nbig_cities['RainTomorrow'].value_counts()\n```\n\n::: {#count-rain-tomorrow .cell-output .cell-output-display execution_count=20}\n```\nRainTomorrow\nNo     11673\nYes     3543\nName: count, dtype: int64\n```\n:::\n:::\n\n\n## Visualising Multiple Variables\n\n- We will often want to know how values of a given variable change based on the values of another.\n- This may not indicate a relationship, but it helps us better understand our data.\n\n::: {#cell-sunshine-location-boxplot .cell execution_count=21}\n``` {.python .cell-code}\nsns.barplot(big_cities, x='Location', y='Sunshine', color=\"#d9dcd6\", edgecolor='black')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/sunshine-location-boxplot-output-1.png){#sunshine-location-boxplot}\n:::\n:::\n\n\n::: {#cell-max-temp-location-boxplot .cell execution_count=22}\n``` {.python .cell-code}\nsns.boxplot(big_cities, x='Location', y='MaxTemp', color=\"#d9dcd6\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/max-temp-location-boxplot-output-1.png){#max-temp-location-boxplot}\n:::\n:::\n\n\n::: {#cell-humidity-rain-tomorrow-boxplot .cell execution_count=23}\n``` {.python .cell-code}\nsns.boxplot(data=big_cities, x='RainTomorrow', y='Humidity3pm', color=\"#d9dcd6\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/humidity-rain-tomorrow-boxplot-output-1.png){#humidity-rain-tomorrow-boxplot}\n:::\n:::\n\n\n::: {#cell-humidity-rain-tomorrow-kde-plot .cell execution_count=24}\n``` {.python .cell-code}\nsns.kdeplot(data=big_cities, x='Humidity3pm', hue='RainTomorrow')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/humidity-rain-tomorrow-kde-plot-output-1.png){#humidity-rain-tomorrow-kde-plot}\n:::\n:::\n\n\n::: {#cell-rainfall-over-time .cell execution_count=25}\n``` {.python .cell-code}\n(\n    big_cities\n    # convert date to datetime\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    # create year-month column\n    .assign(Year_Month=lambda x: x['Date'].dt.to_period('M'))\n    # group by year-month and calculate sum of rainfall\n    .groupby('Year_Month')['Rainfall'].sum()\n    # convert year-month index back to column in dataframe\n    .reset_index()\n    # create year-month timestamp for plotting\n    .assign(Year_Month=lambda x: x['Year_Month'].dt.to_timestamp()) \n    # pass df object to seaborn lineplot\n    .pipe(lambda df: sns.lineplot(data=df, x='Year_Month', y='Rainfall', linewidth=2))\n)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/rainfall-over-time-output-1.png){#rainfall-over-time}\n:::\n:::\n\n\n::: {#cell-sunshine-over-time .cell execution_count=26}\n``` {.python .cell-code}\n(\n    big_cities\n    # convert date to datetime object\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    # set date column as index\n    .set_index('Date')\n    # resample by month-end for monthly aggregations\n    .resample('ME')\n    # calculate mean sunshine per month\n    .agg({'Sunshine': 'mean'})\n    # convert month index back to column in dataframe\n    .reset_index()\n    # pass df object to seaborn lineplot\n    .pipe(lambda df: sns.lineplot(data=df, x='Date', y='Sunshine', color=\"#1f77b4\", linewidth=2))\n)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/sunshine-over-time-output-1.png){#sunshine-over-time}\n:::\n:::\n\n\n::: {#cell-rainfall-sunshine-seasonality .cell execution_count=27}\n``` {.python .cell-code}\nfig, axes = plt.subplots(1, 2)\n\n(\n    big_cities\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    .assign(Month=lambda x: x['Date'].dt.month)\n    .groupby('Month')['Rainfall'].mean()\n    .reset_index()\n    .pipe(lambda df: sns.lineplot(data=df, x='Month', y='Rainfall', color=\"#1f77b4\", linewidth=2, ax=axes[0]))\n)\n\n(\n    big_cities\n    .assign(Date=pd.to_datetime(big_cities['Date']))\n    .assign(Month=lambda x: x['Date'].dt.month) \n    .groupby('Month')['Sunshine'].mean() \n    .reset_index()\n    .pipe(lambda df: sns.lineplot(data=df, x='Month', y='Sunshine', color=\"#ff7f0e\", linewidth=2, ax=axes[1]))\n)\n\nxticks = range(1, 13)\nxticklabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\nfor ax in axes:\n    ax.set_xticks(xticks)  # Set ticks\n    ax.set_xticklabels(xticklabels, rotation=45)\n    ax.set_xlabel('')\n    ax.set_ylabel('')\naxes[0].set_title('Average Rainfall by Month', fontsize=16)\naxes[1].set_title('Average Sunshine by Month', fontsize=16)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-ipynb/rainfall-sunshine-seasonality-output-1.png){#rainfall-sunshine-seasonality}\n:::\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: c:\\Users\\paul.johnson\\git\\code-club\\.venv\\share\\jupyter\\kernels\\python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.5\n---\n",
    "supporting": [
      "index_files\\figure-ipynb"
    ],
    "filters": []
  }
}