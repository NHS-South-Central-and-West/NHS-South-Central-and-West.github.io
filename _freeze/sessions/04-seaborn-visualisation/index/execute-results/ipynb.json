{
  "hash": "f234107cd9e8ff8ac62dbafc9bbb2f9e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Visualisation with Seaborn\"\nformat:\n  html: default\n  ipynb: default\n---\n\nIntro text intro text intro text\n\nWe are using [Australian weather data](https://www.kaggle.com/datasets/jsphyg/weather-dataset-rattle-package), taken from [Kaggle](https://kaggle.com). This dataset is used to build machine learning models that predict whether it will rain tomorrow, using data about the weather every day from 2007 to 2017. To download the data, click <a href=\"data/weatherAUS.csv\" download>here</a>.\n\n::: {#setup .cell execution_count=1}\n``` {.python .cell-code}\n# install necessary packages\nimport matplotlib.pyplot as plt\nfrom matplotlib import rcParams\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n# suppress some annoying warnings\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning) \n\nsns.set_theme(style='darkgrid') # If we don't call this, we just get default matplotlib styling\nsns.set_context(\"notebook\") # Set an overall scale. Notebook is the default. In increasing size: paper, notebook, talk, poster.\nrcParams['font.sans-serif'] = ['Calibri','Segoe UI','Arial'] # use a nicer font in matplotlib (if available)\n```\n:::\n\n\n::: {#import-data .cell execution_count=2}\n``` {.python .cell-code}\n# import the dataset\ndf = pd.read_csv('data/weatherAUS.csv')\n```\n:::\n\n\n## Data manipulation\n\nBefore we start actually generating some visuals, we need to make sure our Date column contains proper datetimes. We're also going to drop the years with partial data so that our dataset only has full years. Finally we're going to change the RainTomorrow field to contain a 0 or a 1 rather than yes/no.\n\n::: {#988413ab .cell execution_count=3}\n``` {.python .cell-code}\n# convert date column to datetime\ndf['Date'] = pd.to_datetime(df['Date'])\n\n# drop the partial years (2007,2017)\ndf['year'] = df['Date'].dt.year\ndf = df[~df['year'].isin([2007,2017])]\n\n# convert 'RainTomorrow' to a numeric variable, where 'Yes' = 1 and 'No' = 0.\ndf['RainToday']=df['RainToday'].replace({'Yes': 1, 'No': 0, 'NA':0}).fillna(0).astype(int)\ndf['RainTomorrow']=df['RainTomorrow'].map({'Yes': 1, 'No': 0,'NA': 0}).fillna(0).astype(int); \n\n# little tip: the semicolon suppresses textual output when we don't want it\n```\n:::\n\n\nNext, we're going to create some helper dataframes by filtering, grouping and pivoting the data. These will be used for different types of visuals later.\n\n::: {#ff0fc7ef .cell execution_count=4}\n``` {.python .cell-code}\n# we need a month order for our \"mmm\" months - there is probably an official way of doing this...\nmonth_order = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n# build a month column\ndf['month'] = df['Date'].dt.strftime('%b') # Add a column that just contains the month in mmm format\ndf['month'] = pd.Categorical(df['month'], categories=month_order, ordered=True) # Make it categorical using our custom order so that it appears in the right order\n\n# we're going to filter to top 5 cities from now on\ndf_top5Cities = df[df['Location'].isin(['Perth','Adelaide','Sydney','Melbourne','Brisbane'])]\n\n# a grouped dataframe with the number of rainy days per year and month, and location\ndf_top5Cities_rainyDays = df_top5Cities.groupby(['Location','year', 'month'])['RainToday'].sum().reset_index()\n\n# a couple of fully-pivoted dataframes\ndf_top5Cities_Rainfall_grouped = df_top5Cities.groupby(['Location', 'month'])['Rainfall'].mean().reset_index()\ndf_top5Cities_Rainfall_pivoted = df_top5Cities_Rainfall_grouped.pivot(index=\"Location\",columns=\"month\", values=\"Rainfall\")\ndf_top5Cities_rainyDays_pivoted = df_top5Cities.groupby(['Location', 'month'])['RainToday'].sum().reset_index().pivot(index=\"Location\",columns=\"month\", values=\"RainToday\")\ndf_top5Cities_monthly_rainyDays_pivoted = df_top5Cities.groupby(['Location', 'month','year'])['RainToday'].sum().reset_index().groupby(['Location','month'])['RainToday'].mean().reset_index().pivot(index=\"Location\",columns=\"month\", values=\"RainToday\")\n\n\n# we need a sort order for our city names. This just returns an array with our city names in alphabetical order.\ncolOrder_top5Cities=sorted(df_top5Cities['Location'].unique())\n```\n:::\n\n\nTo enhance a chart we're going to build later, we're going to dynamically calculate some text describing our data range.\n\n::: {#8f6c1893 .cell execution_count=5}\n``` {.python .cell-code}\n# Calculate the date range dynamically; we're going to use this later...\ndate_min = df['Date'].min().strftime('%Y')\ndate_max = df['Date'].max().strftime('%Y')\ndate_range = f\"{date_min} - {date_max}\"\n\nprint(date_range)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2008 - 2016\n```\n:::\n:::\n\n\n:::\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: C:\\Users\\jonas.willemsen\\AppData\\Local\\Programs\\Python\\Python313\\share\\jupyter\\kernels\\python3\n---\n",
    "supporting": [
      "index_files\\figure-ipynb"
    ],
    "filters": []
  }
}